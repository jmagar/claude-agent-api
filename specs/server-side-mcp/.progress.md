---
spec: server-side-mcp
phase: requirements
task: 0/0
updated: 2026-01-15T17:00:00Z
---

# Progress: server-side-mcp

## Original Goal

Add server-side MCP server configuration so all API requests automatically get access to configured MCP servers (making tools from MCP servers available through OpenAI compatibility layer)

## Completed Tasks

- Research phase completed (2026-01-15)
- Requirements phase completed (2026-01-15)
- Design phase completed (2026-01-15)
- [x] 1.1 Create basic config loader with file reading
- [x] 1.2 Add environment variable resolution to config loader
- [x] 1.3 Quality checkpoint passed
- [x] 1.4 Extend McpServerConfigService with API-key scoping
- [x] 1.5 Update MCP server routes with API-key filtering
- [x] 1.6 Quality checkpoint passed
- [x] 1.7 Implement basic config merge in loader
- [x] 1.8 Create config injector service
- [x] 1.9 Quality checkpoint passed
- [x] 1.10 Wire config injector into AgentService - 9875ecd
- [x] 1.11 Add DI providers for new services - d04f332

## Current Task

Awaiting next task

## Learnings

- **Infrastructure Already Exists**: MCP filesystem discovery (`McpDiscoveryService`) and database storage (`McpServerConfigService`) already implemented but not applied to all requests
- **Three-Tier Config System Recommended**: Application-level (file) + API-key-level (database) + request-level (existing) with clear merge precedence
- **Security Critical**: Per-API-key scoping essential for multi-tenant isolation; credential sanitization already implemented in management routes
- **Hybrid Approach Best**: Configuration file (`.mcp-server-config.json`) for global defaults + Redis database for per-tenant overrides
- **Environment Variable Resolution**: Must be done server-side at load time, NOT from user input (security constraint T140)
- **OpenAI Impact**: Server-side MCP enables automatic tool availability in `/v1/chat/completions` endpoint without client configuration
- **MCP Lifecycle Phases**: Initialization (capability negotiation) → Operation (tool execution) → Shutdown (graceful termination)
- **Configuration Merge Strategy**: Application < API-key < Request (lowest to highest priority) for conflict resolution
- **No New Dependencies**: All required infrastructure exists (pydantic-settings, Redis, structlog, Claude SDK with MCP support)
- **Quality Commands Validated**: ruff (lint/format), ty (type check), pytest (unit/contract/integration), coverage targets 80%+
- **Requirements Phase Completed**: Five user stories created covering application config, API-key scoping, merge strategy, security, and OpenAI integration
- **TDD Emphasis**: All acceptance criteria designed for test-first development (RED-GREEN-REFACTOR cycle)
- **Scope Clarity**: Opt-out mechanism with empty `mcp_servers: {}` provides explicit override capability
- **Backward Compatibility Critical**: Existing per-request `mcp_servers` field must work unchanged (100% test pass requirement)
- **Multi-Tenancy Isolation Pattern**: Redis keys use `mcp_server:{api_key}:{server_name}` format for tenant separation
- **Security Risk Mitigation**: Command injection, SSRF, credential leakage addressed with existing validators + new file permission checks
- **Success Metrics Defined**: 90% test coverage, <100ms config load, <10ms Redis lookup, zero security vulnerabilities
- **Configuration Loader as Coordinator**: The `McpConfigLoader` acts as the central coordinator for all three tiers, avoiding tight coupling between filesystem, database, and request sources
- **Validation at Multiple Layers**: Security validation occurs at three points (load, merge, SDK pass) providing defense in depth without performance penalty (cached results)
- **Opt-Out Mechanism Critical**: Empty dict `{}` vs `null` distinction provides explicit control without breaking existing behavior - this was a key design decision for backward compatibility
- **API-Key Scoping Pattern Reusable**: The `mcp_server:{api_key}:{name}` Redis key pattern is a clean multi-tenancy solution applicable to other scoped resources
- **TDD-Friendly Architecture**: Separating concerns into small, focused services (`Loader`, `Injector`, `Validator`) makes unit testing straightforward and enables true RED-GREEN-REFACTOR workflow
- **Performance vs Security Tradeoff**: Environment variable resolution at load time (cached) balances security (T140 requirement) with performance (no per-request resolution overhead)
- **Existing Infrastructure Leverage**: Reusing `McpDiscoveryService`, `McpServerConfigService`, and security validators from `schemas/validators.py` reduces implementation scope significantly
- **Integration Point Minimal**: Only one integration point in `AgentService` (before `OptionsBuilder`) keeps changes localized and reduces risk of breaking existing flows
- **Type Safety Enables Refactoring**: Explicit `TypedDict` for `McpServerInfo` and Pydantic models for validation schemas make merge logic type-safe and refactor-friendly
- **Backward Compatibility Testing First**: Contract tests verifying existing test suite passes unchanged (NFR-7) should be written in Phase 1, not Phase 4, to catch breaking changes early
- **Task Planning: POC-First Essential**: Breaking 46 tasks into 4 phases (POC, TDD, Integration, Quality) ensures fast validation before comprehensive testing
- **Task Planning: TDD Baked Into Phase 2**: Each component (loader, merger, validator, injector) has RED-GREEN-REFACTOR subsection ensuring tests written before implementation
- **Task Planning: Quality Checkpoints Every 2-3 Tasks**: Early and frequent verification prevents technical debt accumulation, makes debugging easier by limiting scope
- **Task Planning: Security Tests Separate Phase**: Dedicated security test phase (3.3) ensures command injection, SSRF, and credential leakage verified before production
- **Task Planning: Coverage Target Enforcement**: Task 4.1 explicitly verifies 90% coverage, ensures comprehensive test suite before merging
- **Task Planning: Documentation as Quality Gate**: Docstrings and CLAUDE.md updates in Phase 4 ensure feature is user-ready before PR creation
- **Task Planning: Dependency on Existing Tests**: Contract tests (3.7) re-run existing test suite to catch regressions, critical for backward compatibility guarantee
- **Config Injector Implementation**: Coordinates loader and database service, converts between record format and Pydantic schema format, handles all three merge scenarios (null, empty dict, with values)
- **Type Conversion Critical**: McpServerRecord → dict → McpServerConfigSchema conversion ensures proper validation and format compatibility with SDK
- **Integration Strategy**: AgentService accepts optional McpConfigInjector dependency, calls inject() before query execution only if injector exists and api_key is non-empty
- **Backward Compatibility Pattern**: Made api_key parameter optional with default "" to avoid breaking existing tests during POC phase
- **Route Threading**: api_key must be threaded through all call chains (query routes → agent service → injector), but pattern is consistent across all endpoints

## Blockers

- None currently

## Next

Task 1.12: Create example config file
